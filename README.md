TEST

echo -e "hello\nworld" > infile
./pipex infile "ls -l" "wc -l" outfile

bonus
echo -e "hello\nworld\nfoo\nbar" > infile
./pipex_bonus infile "grep o" "sort" "wc -l" outfile
< infile grep o | sort | wc -l > outfile

./pipex_bonus here_doc EOF "cat" "wc -l" outfile

valgrind
valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes ./pipex infile "ls -l" "wc -l" outfile

## Data pid_t
это просто int, но стандарт говорит: «не используйте просто int, используйте pid_t». PID = Process ID — уникальный номер, который система выдаёт каждому процессу при его создании.

## Func pipe()
это виртуальный файл, который существует только в памяти ядра, нельзя «найти» его в папке  исчезает, как только оба конца (fd[0] и fd[1]) закрыли

## Func fork()
👴 родитель	> 0 (PID ребёнка)
👶 ребёнок	= 0
❌ ошибка	< 0

## write fd[1] ..., ...
| дескриптор     | куда пишет           |
| -------------- | -------------------- |
| `1` (`stdout`) | терминал             |
| `2` (`stderr`) | терминал (ошибки)    |
| `fd[1]`        | труба (в буфер ядра) |

## close(fd[0]) || close(fd[1])
fd[0] — для чтения
fd[1] — для записи

в дочернем процессе ты хочешь только читать из трубы → тебе не нужен конец для записи

в родительском процессе ты хочешь только писать в трубу → тебе не нужен конец для чтения

👴Родитель:
close(fd[0]);         // читать не будем
write(fd[1], …);      // пишем
close(fd[1]);         // всё, закончили писать
👶Дочерний:
close(fd[1]);         // писать не будем
read(fd[0], …);       // читаем
close(fd[0]);         // всё, закончили читать
 Когда оба конца закрыли — труба исчезает.|
 Чтобы снова писать или читать, нужно снова вызвать pipe(fd) и получить новую трубу.

## waitpid
waitpid() — это функция, с помощью которой родительский процесс ждёт, пока один из его дочерних процессов завершится.
waitpid(pid1, NULL, 0);
pid1 — это PID дочернего процесса, который ты получил после fork().
NULL — указатель на статус завершения (в данном случае он не нужен, поэтому NULL).
0 — опции (0 → ждать, пока процесс завершится).

## wait
самая простая форма ожидания. 
ждёт любой дочерний процесс, который завершился.
возвращает его PID.
статус можно (необязательно) забрать.

## Флаг O_RDONLY
O_RDONLY	только читать
O_WRONLY	только писать
O_RDWR	читать и писать

## Флаг FILENO
STDIN_FILENO	0	читать //перенаправив его на файл, ты будешь читать данные из этого файла вместо ввода с клавиатуры
STDOUT_FILENO	1	писать //все данные, которые программа выводит в стандартный вывод, будут записываться в этот файл, а не выводиться на экран.
STDERR_FILENO	2	ошибки